/**!
 * $fx.genetics ($DNA)
 * 
 * @version 1.0.0
 * @author Joseph Miclaus
 * @license UNLICENSED - see fx.genetics.min.js.LICENSE.txt for details.
 * Copyright (c) 2026 Joseph Miclaus. All rights reserved.
 */
!function(e){"use strict";const author="Joseph Miclaus",n="$fx.genetics",t="1.0.0";if(void 0===e.$fx)throw new Error(`[${n}] $fx not found. Make sure to include the fxhash script (fxhash.min.js) before $fx.genetics addon (fx.genetics.min.js)`);const r=e.$fx;r.genetics=function(){let e;const o="tiered",i="weighted",a="sliding",s="hybrid",c="paired",f=":",u=e=>void 0!==e,l=e=>"function"==typeof e,d=e=>"string"==typeof e&&e.length>0,h=e=>"number"==typeof e&&isFinite(e),$=e=>d(e)||h(e)||"boolean"==typeof e,w=e=>Array.isArray(e)&&2===e.length&&Number.isInteger(e[0])&&Number.isInteger(e[1])&&e[0]<=0&&e[1]<=0,m=[o,i],v=[a,s,c],p=e=>"object"==typeof e&&null!==e&&(Object.getPrototypeOf(e)===Object.prototype||null===Object.getPrototypeOf(e)),y=e=>Array.isArray(e)&&e.length>0,b=e=>h(e)&&e>0&&e<=1,g=e=>h(e)&&e>=0&&e<=1,E=e=>Number.isInteger(e)&&(0==e||1==e),x=(e,n)=>{for(const t of n)if("boolean"==typeof e&&"string"==typeof t&&(e&&"true"===t||!e&&"false"===t)||"string"==typeof e&&"boolean"==typeof t&&("true"===e&&t||"false"===e&&!t)||h(e)&&"string"==typeof t&&t===String(e)||"string"==typeof e&&h(t)&&e===String(t))return!0;return!1};function S(t){return e={t:t,o:o,i:a,u:[],l:new Set,h:[],$:!1,m:!1,v:!1,p:!1,S:!1,C:!1,k:!1,M:1e3,j:!1},function(){const t=e.t;if(!y(t))throw new Error(`[${n}] genetics() accepts a non-empty array.`);const r=t.length,o=new Set,i=new Set;for(let e=0;e<r;e++){const r=t[e],a=e+1,s=`[${n}] gene[${e}]`;if(!p(r))throw new Error(`${s} must be a plain object.`);if(!y(r.variants))throw new Error(`${s} must have a non-empty "variants" array.`);if(u(r.id)){const e=r.id;if(!d(e))throw new Error(`${s}: "id" must be a non-empty string if defined.`);if(/^G\d+$/.test(e)&&Number(e.slice(1))!==a)throw new Error(`${s}: Reserved gene id "${e}" cannot be used for gene at position ${a}. Leave empty to auto-assign to "G${a}" or provide a custom id.`);if(!/^[A-Z][A-Z0-9_]*$/i.test(e))throw new Error(`${s}: Provided id "${e}" is invalid. Must start with a letter and contain only letters, digits, or "_".`);if(o.has(e))throw new Error(`${s}: Cannot use gene id "${e}" because it is already used by another gene.`);o.add(e)}if(u(r.name)){const e=r.name;if(!d(e))throw new Error(`${s}: "name" must be a non-empty string if defined.`);if(e.startsWith("#"))throw new Error(`${s}: Gene name "${e}" cannot start with the reserved character "#".`);if(i.has(e))throw new Error(`${s}: Cannot use gene name "${e}" because it is already used by another gene.`);i.add(e)}const c=r.variants,l=c.length,h=new Set,w=new Set;let m=0,v=0;for(let e=0;e<l;e++){const n=c[e],t=`${s}.variants[${e}]`;if(p(n)){const e=n.value;if(!u(e))throw new Error(`${t} must, as an object, define a "value" property.`);if(!$(e))throw new Error(`${t}: "value" must be a non-empty string, finite number, or boolean.`);if(w.has(e))throw new Error(`${t}: Cannot use variant value "${e}" because it is already used by another variant of the same gene.`);if(x(e,w))throw new Error(`${t}: Cannot use variant value "${e}" (${typeof e}) because there is already a similar variant value in the same gene.`);w.add(e);const r=n.name;if(u(r)){if(!d(r))throw new Error(`${t}: "name" must be a non-empty string if defined.`);if(h.has(r))throw new Error(`${t}: Cannot use variant name "${r}" because it is already used by another variant of the same gene.`);h.add(r)}const o=n.chance;if(u(o)){if(!b(o))throw new Error(`${t}: "chance" must be a number between 0 (exclusive) and 1 (inclusive).`);m+=o}else v++}else{if(!$(n))throw new Error(`${s}.variants[${e}] must be a non-empty string, finite number, boolean, or a plain object.`);if(w.has(n))throw new Error(`${t}: Cannot use variant value "${n}" because it is already used by another variant of the same gene.`);if(x(n,w))throw new Error(`${t}: Cannot use variant value "${n}" (${typeof n}) because there is already a similar variant value in the same gene.`);w.add(n),v++}}if(m>1)throw new Error(`${s}: The sum of defined variant chances exceeds 1.`);if(u(r.mutations)){const e=r.mutations;if(!y(e))throw new Error(`${s}: "mutations" must be a non-empty array if defined.`);const n=e.length;for(let t=0;t<n;t++){const n=e[t],r=`${s}.mutations[${t}]`;if(!p(n))throw new Error(`${r} must be a plain object.`);{const e=n.value;if(!u(e))throw new Error(`${r} must, as an object, define a "value" property.`);if(!$(e))throw new Error(`${r}: "value" must be a non-empty string, finite number, or boolean.`);if(w.has(e))throw new Error(`${r}: Cannot use mutation value "${e}" because it is already used by a variant of the same gene.`);if(x(e,w))throw new Error(`${r}: Cannot use mutation value "${e}" (${typeof e}) because there is already a similar variant value in the same gene.`);w.add(e);const t=n.name;if(u(t)){if(!d(t))throw new Error(`${r}: "name" must be a non-empty string if defined.`);if(h.has(t))throw new Error(`${r}: Cannot use mutation name "${t}" because it is already used by another variant of the same gene.`);h.add(t)}const o=new Set,i=n.requires;if(!u(i))throw new Error(`${r} must, as an object, define a "requires" array.`);if(!y(i))throw new Error(`${r}: "requires" must be a non-empty array.`);const a=i.length;for(let e=0;e<a;e++){const n=i[e],t=`${r}.requires[${e}]`;if(!d(n))throw new Error(`${t} must be a non-empty string.`);if(-1===n.indexOf(f))throw new Error(`${t} must be in the format "GeneID:VariantValue".`);if(o.has(n))throw new Error(`${t}: Cannot use require selector "${n}" because it is already used for this mutation.`);{const e=n.split(f);if(2!==e.length&&0!==e[0].length&&0!==e[1].length)throw new Error(`${t} must split into exactly two non-empty strings: "GeneID:VariantValue".`)}o.add(n)}}}}}e.$=!0}(),M(),j(),A(),function(){if(e.i===c)e.A=[0,0,.125,.125,.25];else e.A=[0,.125,.25]}(),function(){if(e.i===c)e.D=[0,0,.005];else e.D=[0,.005]}(),function(){const t=e.t,r=t.length;for(let o=0;o<r;o++){const r=t[o],i=r.variants;u(r.id)||(r.id="G"+(o+1)),e.u.push(r.id),u(r.name)&&e.l.add(r.name);const a=i.length;let s=0,c=0;for(let e=0;e<a;e++){let n=i[e];$(n)&&(n={value:n},i[e]=n),u(n.chance)?s+=n.chance:c++}if(c>0){const e=(1-s)/c;if(e<=0)throw new Error(`[${n}] gene[${o}] has ${c} variants without a defined chance, but no remaining chance is left to distribute.`);e<1e-6&&console.warn(`[${n}] gene[${o}] auto-assigned chance (${e}) is very small (< 1ppm). This may lead to floating point precision issues.`);for(let n=0;n<a;n++){const t=i[n];u(t.chance)||(t.chance=e)}}}}(),function(){const t=e.t,r=t.length,o=new Set(e.u),i={};for(let e=0;e<r;e++){const n=t[e],r=n.id,o=n.variants,a=n.mutations,s=o.length,c=new Set;for(let e=0;e<s;e++){const n=o[e];p(n)?c.add(n.value):c.add(n)}if(u(a)){const e=a.length;for(let n=0;n<e;n++){const e=a[n];p(e)&&u(e.value)&&c.add(e.value)}}i[r]=c}for(let e=0;e<r;e++){const r=t[e].mutations;if(!u(r))continue;const a=r.length;for(let t=0;t<a;t++){const a=r[t].requires,s=a.length,c=`[${n}] gene[${e}].mutations[${t}]`;for(let e=0;e<s;e++){const n=a[e],[t,r]=n.split(f),s=`${c}.requires[${e}]`;if(!o.has(t))throw new Error(`${s}: "${n}" refers to unknown geneId "${t}".`);const u=i[t];let l=!1;for(const e of u)if(e===r||"number"==typeof e&&String(e)===r||"boolean"==typeof e&&String(e)===r){l=!0;break}if(!l)throw new Error(`${s}: "${n}" refers to an unknown value "${r}" for geneId "${t}".`)}}}}(),S}function C(){const t=e.o===i,r=e.N,o=t?"weighted":"tiered",a=`[${n}] hidden() chances make primary variants less likely in "${o}" mode.`;if(r<=0)throw new Error(`${`[${n}] hidden() chances leave no chance for primary genes in "${o}" mode.`} ${t?"Sum of hidden chances is 1 or more.":"Primary gene chance is 0."}`);r<=.5&&console.warn(`${a} ${t?"Sum of hidden chances is 0.5 or more.":"Primary gene chance is 0.5 or less."}`)}function k(e,n=", "){return e.map(e=>`"${e}"`).join(n)}function M(){const n=e.i,t=e.G;switch(n){case s:e.P=e=>0===e||t&&e%t===0?[0,0]:[-1,0];break;case c:e.P=e=>e<2?[0,0]:t&&e%t===0?e%2==0?[-1,0]:[-2,0]:e%2==0?[-2,-1]:[-3,-2];break;default:e.P=e=>0===e?[0,0]:1===e||t&&e%t===0?[-1,0]:[-2,-1]}}function j(){if(e.o===i)e.T=[.1875,.046875,.015625];else e.T=[.25,.25,.25]}function A(){let n=e.T;if(e.o!==i){const t=n.length,r=t+1,o=Array(r).fill(0),i=1<<t;for(let e=0;e<i;e++){let i=1;const a=Array.from({length:r},(e,n)=>n);for(let r=t;r>0;r--){const o=r-1;if(e>>t-r&1){const e=a[r];a[r]=a[o],a[o]=e,i*=n[o]}else i*=1-n[o]}o[a[0]]+=i}e.I=o.slice(1),n=e.I}e.V=n.reduce((e,n)=>e+n,0),e.N=1-e.V,Object.defineProperty(S,"primary",{value:e.N,enumerable:!0,configurable:!0})}function D(e){return function(n){const t=e(n);return w(t)?t:[0,0]}}function N(e){return function(n){const t=e(n);return!h(t)||t<0?0:t>1?1:t}}function G(t,r,o){const i=e.M;for(let a=0;a<=i;a++){const i=t(a);if(!r(i)){const t=o(()=>i)();console.warn(`[${n}] ${e.O}() returned an invalid value at depth ${a}. Received ${JSON.stringify(i)} (invalid), but will be using ${JSON.stringify(t)} (valid) instead. This might lead to unexpected results.`);break}}}function P(n){const t=e.A;if(u(t)){const e=t.length;return n<e?t[n]:t[e-1]}return e.q(n)}function T(n){const t=e.D;if(h(t))return t;if(u(t)){const e=t.length;return n<e?t[n]:t[e-1]}return e.J(n)}function I(e,t){const o=r.randAt(t),i=r.randAt(t),a=e.length;let s=0;for(let n=0;n<a;n++)if(s+=e[n].chance,o<s)return e[n];return console.info(`[${n}] chances did not sum up to 1 (sum = ${s}) when choosing a variant. Using fallback random selection.`),e[Math.floor(i*a)]}function V(e,n,t,r){const o=new Array(n);for(let i=0;i<n;i++){const n=I(e,r),a={value:n.value};u(n.name)&&(a.name=n.name),t&&(a.preSwapIndex=i),u(n.parentIndex)&&(a.parentIndex=n.parentIndex),n.isMutation&&(a.isMutation=!0),o[i]=a}return o}function O(n){const t={},r=e.t,i=r.length,a=e.o===o,s=e.T.length+1;for(let e=0;e<i;e++){const o=r[e],i=o.id,c=o.variants;t[i]=V(c,s,a,n)}return t}function q(n,t){const o=e.T;for(let e=n.length-1;e>0;e--){const i=e-1,a=o[i];if(r.randAt(t)<a){const t=n[e];n[e]=n[i],n[i]=t}}return n}function J(e,n){if(e.has(n))return!0;if("true"===n)return e.has(!0);if("false"===n)return e.has(!1);const t=Number(n);return!h(t)&&String(t)===n&&e.has(t)}function _(n,t){const o={},i={},a=e.t,s=e.u,c=s.length,l=n.length,d=e.N,h=e.T;for(let e=0;e<l;e++){const t=n[e];for(let n=0;n<c;n++){const r=s[n],o=t[r];u(i[r])||(i[r]=new Map);const a=i[r],c=o.length;for(let n=0;n<c;n++){const t=o[n],r=t.value;a.has(r)||a.set(r,{weight:0,name:t.name,parentIndex:e});const i=0===n?d:h[n-1];a.get(r).weight+=i}}}for(let e=0;e<c;e++){const n=a[e],r=n.id,o=n.mutations;if(!u(o))continue;u(i[r])||(i[r]=new Map);const s=i[r],c=o.length;for(let e=0;e<c;e++){const n=o[e],r=n.value,a=n.requires,c=a.length;let l=0;for(let e=0;e<c;e++){const[n,t]=a[e].split(f),r=i[n];if(!u(r))break;if(!J(r,t))break;l++}l!==c||s.has(r)||s.set(r,{weight:P(t),name:n.name,isMutation:!0})}}for(let n=0;n<c;n++){const c=s[n],f=i[c];if(!u(f))continue;let l=0;for(const[,e]of f)l+=e.weight;const d=new Array(f.size);let h=0;for(const[e,n]of f){const t={value:e};u(n.name)&&(t.name=n.name),t.chance=n.weight/l,t.parentIndex=n.parentIndex,n.isMutation&&(t.isMutation=!0),d[h]=t,h++}const $=e.T.length+1;o[c]=V(d,$,!1,t);const w=T(t),m=a[n].variants;for(let e=0;e<$;e++)if(!o[c][e].isMutation&&r.randAt(t)<w){const n=I(m,t),r={value:n.value};u(n.name)&&(r.name=n.name),r.isAnomaly=!0,o[c][e]=r}}return o}function H(n,t){const o={},i=e.t,a=e.u.length,s=n.length,c=e.T.length+1,l={};for(let e=0;e<a;e++){const a=i[e].id,f=new Array(s);for(let e=0;e<s;e++)f[e]=q(structuredClone(n[e][a]),t);l[a]=f;const u=new Array(c);for(let e=0;e<c;e++){const n=Math.floor(r.randAt(t)*s);u[e]=structuredClone(f[n][e]),u[e].parentIndex=n}o[a]=u}const d=T(t),h=P(t);for(let e=0;e<a;e++){const n=i[e],a=n.id,$=n.mutations,w=u($);let m;if(w){m=Array.from({length:c},()=>[]);const e=$.length;for(let n=0;n<e;n++){const e=$[n],t=e.requires,r=t.length;let o=new Array(r);for(let e=0;e<r;e++){const[n,r]=t[e].split(f);o[e]={id:n,rawValue:r}}for(let n=0;n<c;n++){let t=!0;for(let e=0;e<r;e++){const r=o[e],i=l[r.id];if(!u(i)){t=!1;break}let a=!1;for(let e=0;e<s;e++){const t=i[e][n].value;if(J(new Set([t]),r.rawValue)){a=!0;break}}if(!a){t=!1;break}}t&&m[n].push(e)}}}const v=n.variants;for(let e=0;e<c;e++){const n=w&&m?m[e]:[],i=n.length>0&&r.randAt(t)<h,s=r.randAt(t)<d;if(!i&&!s)continue;const c=o[a][e];let f;if(i){f=n[Math.floor(r.randAt(t)*n.length)]}else s&&(f=I(v,t));const l={value:f.value};u(f.name)&&(l.name=f.name),l.preSwapIndex=c.preSwapIndex,i?l.isMutation=!0:s&&(l.isAnomaly=!0),o[a][e]=l}}return o}function L(n){const t=e.P(n),i=t.length,a=[];for(let r=0;r<i;r++){const o=t[r];if(0===o)a.push(O(n));else if(o<0){const t=n+o;t<0?a.push(O(n)):a.push(e.h[t].genome)}}return{id:r.lineage[n],genome:e.o===o?H(a,n):_(a,n),parents:a}}function R(n){const t=e.h[r.depth].genome[n];if(u(t))return t}function Z(n){const t=e.t,r=t.length;for(let e=0;e<r;e++){const r=t[e];if(r.name===n)return R(r.id)}}function F(e){const n=R(e);if(u(n))return n[0]}function U(n,t){const o=e.h[r.depth].parents[t];if(!u(o))return;const i=o[n];return u(i)?i:void 0}function z(n,t){const r=e.t,o=r.length;for(let e=0;e<o;e++){const o=r[e];if(o.name===n)return U(o.id,t)}}function B(t,r){if(r&&t.startsWith("#")){const r=t.slice(1);if(-1===e.u.indexOf(r))throw new Error(`[${n}] ${e.O}() gene with id "${r}" does not exist.`);return[r,!0]}if(!e.l.has(t))throw new Error(`[${n}] ${e.O}() gene with name "${t}" does not exist.`);return[void 0,!1]}function K(){if(!e.$)throw new Error(`[${n}] ${e.O}() can only be called after genetics().`)}function Q(t){if(t)throw new Error(`[${n}] ${e.O}() can only be called once.`)}function W(){if(!e.k)throw new Error(`[${n}] ${e.O}() must be called after evolve().`)}function X(t,r){if(r)throw new Error(`[${n}] ${e.O}() must be called before ${t}().`)}function Y(){X("evolve",e.k)}function ee(t){if(o=t,!(Number.isInteger(o)&&o>=0&&o<r.lineage.length)){if(t>r.depth)throw new Error(`[${n}] ${e.O}() cannot accept depth greater than $fx.depth (${r.depth}).`);throw new Error(`[${n}] ${e.O}() accepts a valid depth (0 to $fx.depth).`)}var o}function ne(t,r,o){if(!r.includes(t))throw new Error(`[${n}] ${e.O}() received an invalid ${o} "${t}". Valid options: ${k(r)}.`)}function te(t,r,o=!0){const i=t.length;for(let a=0;a<i;a++)if(!r(t[a])){const t="inclusive",r=o?t:"exclusive";throw new Error(`[${n}] ${e.O}() chances[${a}] must be a number between 0 (${r}) and 1 (${t}).`)}}return Object.defineProperty(S,"version",{value:t,enumerable:!0}),S.mode=function(n){return e.O="mode",K(),Q(e.m),X("hidden",e.p),Y(),ne(n,m,"mode"),e.o=n,j(),A(),C(),e.m=!0,S},S.parents=function(t,r){if(e.O="parents",K(),Q(e.v),Y(),d(t)){if(ne(t,v,"parent selection strategy"),u(r)){if(Number.isInteger(r)&&r>1)throw new Error(`[${n}] ${e.O}() reseedInterval must be an integer greater than 1.`);e.G=r}e.i=t,M()}else{if(!l(t))throw new Error(`[${n}] ${e.O}() accepts either a non-empty string or a function.`);u(r)&&console.warn(`[${n}] ${e.O}() reseedInterval is only relevant when using a build-in parent selection strategy (${k(v)}).`),G(t,w,D),e.i="custom",e.P=D(t)}return e.v=!0,S},S.hidden=function(t){if(e.O="hidden",K(),Q(e.p),Y(),!y(t))throw new Error(`[${n}] ${e.O}() accepts a non-empty array.`);te(t,b,!1);return e.T=t,A(),C(),e.p=!0,S},S.mutations=function(t){if(e.O="mutations",K(),Q(e.S),Y(),y(t))te(t,g),e.A=t,e.q=void 0;else{if(!l(t))throw new Error(`[${n}] ${e.O}() accepts either a non-empty array or a function.`);G(t,g,N),e.A=void 0,e.q=N(t)}return e.S=!0,S},S.anomalies=function(t){if(e.O="anomalies",K(),Q(e.C),Y(),y(t))te(t,g),e.D=t,e.J=void 0;else if(g(t))t>.25&&console.warn(`[${n}] ${e.O}() chance might be quite high (> 0.25). Note that this chance is applied on every variant at every depth (unless a mutation occured). This might lead to an unexpectedly high number of anomalies.`),e.D=t,e.J=void 0;else{if(!l(t))throw new Error(`[${n}] ${e.O}() accepts either a number between 0 (inclusive) and 1 (inclusive), a non-empty array, or a function.`);G(t,g,N),e.D=void 0,e.J=N(t)}return e.C=!0,S},S.evolve=function(){e.O="evolve",K(),Q(e.k);const n=e.h,t=r.depth;for(let e=0;e<=t;e++)r.randAt.reset(e),n.push(L(e)),r.randAt.reset(e);const o={},i=e.t,a=i.length;for(let e=0;e<a;e++){const n=i[e];if(!1!==n.exposed){const e=n.id,t=F(e);if(u(t)){const r=n.name;o[u(r)?r:e]=u(t.name)?t.name:t.value}}}return r.features(o),e.k=!0,e.O=void 0,S},S.getSchema=function(){return e.O="getSchema",W(),e.O=void 0,e.t},S.getLineage=function(){return e.O="getLineage",W(),e.O=void 0,e.h},S.getGenome=function(n=r.depth){return e.O="getGenome",W(),ee(n),e.O=void 0,function(n=r.depth){return e.h[n].genome}(n)},S.getGenotype=function(t){e.O="getGenotype",W();const r=d(t);if(!r)throw new Error(`[${n}] ${e.O}() accepts a non-empty string as identifier.`);const[o,i]=B(t,r);if(e.O=void 0,r)return i?R(o):Z(t)},S.getPhenotype=function(t){e.O=d(e._)?e._:"getPhenotype",W();const r=d(t);if(!r)throw new Error(`[${n}] ${e.O}() accepts a non-empty string as identifier.`);const[o,i]=B(t,r);if(e.O=void 0,r)return i?F(o):function(e){const n=Z(e);return u(n)?n[0]:void 0}(t)},S.getTrait=function(n){return e._="getTrait",S.getPhenotype(n)},S.getParentGenome=function(t,o=r.depth){if(e.O="getParentGenome",W(),ee(o),!E(t))throw new Error(`[${n}] ${e.O}() accepts a valid parent index (0 or 1).`);return e.O=void 0,e.h[o].parents[t]},S.getParentGenotype=function(t,r){e.O="getParentGenotype",W();const o=d(t);if(!o)throw new Error(`[${n}] ${e.O}() accepts a non-empty string as identifier.`);const[i,a]=B(t,o);if(!E(r))throw new Error(`[${n}] ${e.O}() accepts a valid parent index (0 or 1).`);if(e.O=void 0,o)return a?U(i,r):z(t,r)},S.getParentPhenotype=function(t,r){e.O="getParentPhenotype",W();const o=d(t);if(!o)throw new Error(`[${n}] ${e.O}() accepts a non-empty string as identifier.`);const[i,a]=B(t,o);if(!E(r))throw new Error(`[${n}] ${e.O}() accepts a valid parent index (0 or 1).`);if(e.O=void 0,o)return a?function(e,n){const t=U(e,n);return u(t)?t[0]:void 0}(i,r):function(e,n){const t=z(e,n);return u(t)?t[0]:void 0}(t,r)},S.getParentTrait=function(n,t){return e._="getParentTrait",S.getParentPhenotype(n,t)},S.getHiddenToPrimaryChances=function(){if(e.O="getHiddenToPrimaryChances",W(),e.o===o)return e.I;console.warn(`[${n}] ${e.O}() is only relevant in "${o}" mode.`),e.O=void 0},S.getMutationChance=function(n=r.depth){return e.O="getMutationChance",W(),ee(n),e.O=void 0,P(n)},S.getAnomalyChance=function(n=r.depth){return e.O="getAnomalyChance",W(),ee(n),e.O=void 0,T(n)},S.toString=function(){return n+" v"+t+" (by "+author+")"},S.M=function(t){if(e.O="validateMaxDepth",K(),Q(e.j),X("parents",e.v),X("mutations",e.S),X("anomalies",e.C),Y(),!Number.isInteger(t)||t<0)throw new Error(`[${n}] ${e.O}() accepts a positive integer as maxDepth.`);return e.O=void 0,e.M=t,e.j=!0,S},S}(),e.$DNA=r.genetics}("undefined"!=typeof window?window:"undefined"!=typeof globalThis?globalThis:"undefined"!=typeof global?global:this);